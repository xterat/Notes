# 正则表达式

## Table of Contents

  * [正则表达式](#正则表达式)
      * [1 匹配单个字符](#1-匹配单个字符)
      * [2 匹配一组字符](#2-匹配一组字符)
      * [3 元字符](#3-元字符)
         * [3.1 空白字符](#31-空白字符)
         * [3.2 特定类别字符](#32-特定类别字符)
            * [3.2.1 数字](#321-数字)
            * [3.2.2 字母数字](#322-字母数字)
            * [3.2.3 空白字符](#323-空白字符)
      * [4 重复匹配](#4-重复匹配)
      * [5 位置匹配](#5-位置匹配)
         * [5.1 单词边界](#51-单词边界)
          * [5.2 字符串边界](#52-字符串边界)
      * [6 子表达式](#6-子表达式)
      * [7 回溯引用](#7-回溯引用)
         * [7.1 替换](#71-替换)
         * [7.2 大小写转换](#72-大小写转换)
      * [8 前后查找](#8-前后查找)
      * [9 嵌入条件](#9-嵌入条件)
         * [9.1 回溯引用条件](#91-回溯引用条件)
      * [10 参考资料](#10-参考资料)

## 1 匹配单个字符

**.**

```
nam.
```

My **name** is Zheng.



**.** 本身需要转译 "\\."

## 2 匹配一组字符

**[]**

```
abc[^0-9]
```

0-9 匹配的是数字, 代表 0-9 这个区间, 前面加上 ^ 就是指除开数字之外的其他字符.

**abcd**

abc1

abc2

0-9, a-z 定义了一个**字符区间**, 区间使用 ASCII 码来确定, 字符区间在 [ ] 中使用.

**-** 只有在 [ ] 之间才是元字符, 在 [ ] 之外就是一个普通字符.

**^** 在 [ ] 中是取非操作.

## 3 元字符

### 3.1 空白字符

| 元字符 | 说明                 |
| ------ | -------------------- |
| [\b]   | 回退（删除）一个字符 |
| \f     | 换页符               |
| \n     | 换行符               |
| \r     | 回车符               |
| \t     | 制表符               |
| \v     | 垂直制表符           |

### 3.2 特定类别字符

#### 3.2.1 数字

| 元字符 | 说明                       |
| ------ | -------------------------- |
| \d     | 数字字符，等价于 [0-9]     |
| \D     | 非数字字符，等价于 \[^0-9] |

#### 3.2.2 字母数字

| 元字符 | 说明                                          |
| ------ | --------------------------------------------- |
| \w     | 大小写字母，下划线和数字，等价于 [a-zA-Z0-9_] |
| \W     | 对 \w 取非                                    |

#### 3.2.3 空白字符

| 元字符 | 说明                                  |
| ------ | ------------------------------------- |
| \s     | 任何一个空白字符，等价于 [\f\n\r\t\v] |
| \S     | 对 \s 取非                            |

\x 匹配十六进制字符，\0 匹配八进制，例如 \x0A 对应 ASCII 字符 10，等价于 \n。

## 4 重复匹配

\+

匹配一个或多个字符

\*

匹配 0 个或多个字符

?

匹配 0 个或 1 个字符

```
[\w.]+@\w+\.\w+
```

[\w.] 匹配的是一个字符加上字母数字和 **.**, 后面加上 + 表示多次匹配. 注意这里 + 的含义并不是像 **.** 那样指一个字符, 而是指前面那个模式的重复. \w+ 匹配的是多个重复的字符. **\.** 匹配的是 **.** 本身.

这个样就能匹配邮箱地址了.

**test@gmail.com**

@@**test@gmail.com**

{n}

匹配 n 个字符

{m, n}

匹配 m ~ n 个字符

{m,}

至少匹配 m 个字符

**\*** 和 **+** 是贪婪型匹配, 在后面加上 **?** 转换为懒惰型匹配, 例如 ***?**, **+?**, **{m, n}?**.

```
h.+l
```

表示的是匹配 a 和 c 这两个字符之间还有若干个字符的模式.

对于 **hello** 的匹配结果是

**hell**o

贪婪型和懒惰型的区别在于, 如果用

```
h.+?l
```

匹配的结果是

**hel**lo

## 5 位置匹配

### 5.1 单词边界

\b

```
\babc\b
```

匹配的是

abcabc

**abc**

### 5.2 字符串边界

^

匹配字符串开头. ^ 用在字符串集合 [] 中表示取非, 在字符串集合之外用作匹配字符串的开头. 换行符 \n 就是字符串的边界.

$

匹配字符串结尾

```
^\s*\/\/.*$
```

匹配的是以空白字符开头的前两个字符是 “//“ ,并且后面有若干字符的字符串

public void fun() {

​     **// 注释 1**

​     int a = 1;

​     int b = 2;

​     **// 注释 2**

​     int c = a + b;

}

## 6 子表达式

()

子表达式的内容可以当成一个独立元素, 即可以将它看成一个字符，并且使用 * 等元字符. 子表达式可以嵌套.

```
(ab){2,}
```

**abab**cab

| 是子表达式中表示或的元字符, 它把左边和右边所有的部分都看成单独的两个部分, 两个部分只要有一个匹配就行.

```
(19|20)\d{2}
```

**1900**

**2010**

1100

```
((25[0-5]|(2[0-4]\d)|(1\d{2})|([1-9]\d)|(\d))\.){3}(25[0-5]|(2[0-4]\d)|(1\d{2})|([1-9]\d)|(\d))
```

这是一个匹配 IP 的正则表达式. 合法的 IP 地址每个部分是 0 - 255 的数字, 每一位包括这些情况:

1. 一位数字
2. 不以 0 开头的两位数字
3. 1 开头的三位数字
4. 2 开头, 第 2 位是 0 - 4 的 3 位数
5. 25 开头, 第 3 位是 0 - 5 的 3 位数

```
(25[0-5]|(2[0-4]\d)|(1\d{2})|([1-9]\d)|(\d))
```

这一部分表示的就是上面的 5 种情况.

```
((25[0-5]|(2[0-4]\d)|(1\d{2})|([1-9]\d)|(\d))\.){3}
```

就表达的是 IP 地址的前 3 位数字的规则, 即每一个数字后面还要加上一个点. 

```
(25[0-5]|(2[0-4]\d)|(1\d{2})|([1-9]\d)|(\d))
```

最后的这个是重复前面的规则.

## 7 回溯引用

\n

引用前面的某个表达式, 其中 n 是序号, 从 1 开始.

``` 
<(h[1-6])>\w*?<\/\1>
```

**\<h1>x\</h1>**

**\<h2>x\</h2>**

\<h3>x\</h1>

### 7.1 替换

例如修改电话号码样式

将 **313-555-1234** 修改为 **(313) 555-1234**

```
(\d{3})(-)(\d{3})(-)(\d{4})
```

这个表达式匹配到了输入电话号码的格式 313-555-1234.

使用替换工具, 输入表达式

```
($1) $3-$5
```

就得到了

(313) 555-1234

其中, \$1 = 313, \$2 = -, \$3 = 555, \$4 = -, \$5 = 1234.

### 7.2 大小写转换

输入 abcd

```
(\w)(\w{2})(\w)
```

替换

```
$1\U$2\E$3
```

得到 aBCd.

## 8 前后查找

?=

向前查找, 规定了尾部匹配的内容

```
\w+(?=@)
```

**abc** @qq.com

向前查找取非是将 (?=) 替换为 (?!)

## 9 嵌入条件

### 9.1 回溯引用条件

判断某个子表达式是否匹配, 如果匹配就继续匹配后面的内容.

```
(\()?abc(?(1)\))
```

子表达式 (\\() 匹配一个左括号, 其后的问号表示匹配 0 个或 1 个. ?(1) 表示当子表达式1成立时, 需要再匹配一个右括号.

**(abc)**

**abc**

(abc

## 10 参考资料

- https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.md